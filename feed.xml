<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://longshilin.com/</id><title>Notes</title><subtitle>Blog for Unity3d Game Development.</subtitle> <updated>2025-02-04T00:34:31+08:00</updated> <author> <name>admin</name> <uri>https://longshilin.com/</uri> </author><link rel="self" type="application/atom+xml" href="https://longshilin.com/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://longshilin.com/"/> <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator> <rights> © 2025 admin </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>01 代码结构</title><link href="https://longshilin.com/posts/01-%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/" rel="alternate" type="text/html" title="01 代码结构" /><published>2025-02-04T00:00:00+08:00</published> <updated>2025-02-04T00:00:00+08:00</updated> <id>https://longshilin.com/posts/01-%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/</id> <content type="text/html" src="https://longshilin.com/posts/01-%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/" /> <author> <name>admin</name> </author> <category term="ET7" /> <summary>项目需求 热更新： 逻辑代码和MonoBehaivor脚本进行分离，才能做热更新 数据跟方法分离，热重载：数据和方法分离，主要用于服务器不停服热更新，客户端也能用，使用场景就是Model和ModelView数据层不变，重载的是Hotfix和HotfixView两个dll，也就是重载的是逻辑部份。 逻辑和表现分离：玩家移动在逻辑层是离散的点，然后表现需要做差值顺滑移动过去；逻辑是同步的，表现是异步的；战斗需要做预表现，客户端释放技能的时候表现层可以提前播放前摇动作，等服务器的技能消息过来；MMO做切换场景的时候，数据是收到一个消息处理一个消息，服务器的切场景是一瞬间的事情，但是客户端需要异步加载，然后客户端在切换场景的时候，服务器可能发过来角色的数据，以及角色附近的玩家信息的等等， 四个程序集是非常优美的设计</summary> </entry> <entry><title>2025-02-03 日志</title><link href="https://longshilin.com/posts/2025-02-03-%E6%97%A5%E5%BF%97/" rel="alternate" type="text/html" title="2025-02-03 日志" /><published>2025-02-03T00:00:00+08:00</published> <updated>2025-02-04T00:24:28+08:00</updated> <id>https://longshilin.com/posts/2025-02-03-%E6%97%A5%E5%BF%97/</id> <content type="text/html" src="https://longshilin.com/posts/2025-02-03-%E6%97%A5%E5%BF%97/" /> <author> <name>admin</name> </author> <category term="日志" /> <summary>今天是2025年大年初六，返沪了。从今天起好好记录博客～～ 下午在高铁上下载了DeepSeek，体验了一下确实很好用，对于国产GPT能做到这样，实属牛逼～</summary> </entry> <entry><title>总结Action Func delegate event四个关键词</title><link href="https://longshilin.com/posts/%E6%80%BB%E7%BB%93Action-Func-delegate-event%E5%9B%9B%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97/" rel="alternate" type="text/html" title="总结Action Func delegate event四个关键词" /><published>2025-01-27T15:34:00+08:00</published> <updated>2025-01-27T15:35:37+08:00</updated> <id>https://longshilin.com/posts/%E6%80%BB%E7%BB%93Action-Func-delegate-event%E5%9B%9B%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97/</id> <content type="text/html" src="https://longshilin.com/posts/%E6%80%BB%E7%BB%93Action-Func-delegate-event%E5%9B%9B%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97/" /> <author> <name>admin</name> </author> <category term="游戏开发" /> <category term="实用工具" /> <summary>通过AI来总结这几个关键词的区别和联系 delegate、Action、Func的定义 delegate 和 Action 都是用于定义委托类型的机制，但它们有一些关键的区别和特定的用途： 1. delegate 定义 : delegate 是一种类型定义，可以用来表示对任何返回值和参数类型的函数的引用。 语法 : 需要显式定义。 public delegate int MyDelegate(int x, int y); 灵活性 : 它允许你定义具有特定返回类型和参数的委托，可以是具有返回值的方法或者是 void 方法。 使用场景 : 当你需要定义自定义签名或者使用返回类型（除了 void）时，可以考虑使用 delegate。 2. Action 定义 : Act...</summary> </entry> <entry><title>2024-10-06 日志</title><link href="https://longshilin.com/posts/2024-10-06-%E6%97%A5%E5%BF%97/" rel="alternate" type="text/html" title="2024-10-06 日志" /><published>2024-10-06T00:00:00+08:00</published> <updated>2025-02-04T00:24:27+08:00</updated> <id>https://longshilin.com/posts/2024-10-06-%E6%97%A5%E5%BF%97/</id> <content type="text/html" src="https://longshilin.com/posts/2024-10-06-%E6%97%A5%E5%BF%97/" /> <author> <name>admin</name> </author> <category term="日志" /> <summary>这是我在博客上发布的第一篇日志，想要通过日志的方式记录我的工作和学习过程，最近很欣赏一个成语厚积薄发 厚积薄发意思是经过长时间的积累和准备，在时机成熟时迅速展现出强大的能力或取得显著的成就。这个成语强调了持续积累的重要性，以及在积累足够的基础上，爆发出潜力或能量。 这四个字的字面意思是“厚重地积累，薄弱地发出”，但实际上指的是在积累经验、知识或资源之后，能够在关键时刻展现出强大的影响力或成功。通常用于鼓励人们在学习、工作或生活中注重积累，不要急于求成，因为厚积才能薄发。 通过记录的方式能够鞭策自己在积累的道路上越走越远，文字记录也是一个归纳的过程，看着自己的沉淀的内容也会更有动力前行。</summary> </entry> <entry><title>位标志</title><link href="https://longshilin.com/posts/%E4%BD%8D%E6%A0%87%E5%BF%97/" rel="alternate" type="text/html" title="位标志" /><published>2024-05-28T15:34:00+08:00</published> <updated>2024-06-19T09:45:28+08:00</updated> <id>https://longshilin.com/posts/%E4%BD%8D%E6%A0%87%E5%BF%97/</id> <content type="text/html" src="https://longshilin.com/posts/%E4%BD%8D%E6%A0%87%E5%BF%97/" /> <author> <name>admin</name> </author> <category term="游戏开发" /> <category term="实用工具" /> <summary>在C#中，使用带有[Flags]特性的枚举来表示一组位标志是非常常见的需求。以下是如何独立使用每个标志、判断某个标志是否被设置以及设置某个标志的示例。 定义枚举 首先，定义一个带有[Flags]特性的枚举： [Flags] public enum GuidanceStatus : int { None = 0, Lottery = 1, EnterAdventure = 1 &amp;amp;lt;&amp;amp;lt; 1, SkillLevelUp = 1 &amp;amp;lt;&amp;amp;lt; 2, AutoDecompose = 1 &amp;amp;lt;&amp;amp;lt; 3, Equipment = 1 &amp;amp;lt;&amp;amp;lt; 4, PetEquipment = 1 &amp;amp;lt;&amp;amp;lt; 5, PetLevelUp = 1 &amp;amp;lt;&amp;amp;lt; 6, AutoAttack = 1 &amp;amp;...</summary> </entry> </feed>
