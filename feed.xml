<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://longshilin.com/</id><title>Notes</title><subtitle>Blog for Unity3d Game Development.</subtitle> <updated>2024-05-28T15:13:41+08:00</updated> <author> <name>Elon</name> <uri>https://longshilin.com/</uri> </author><link rel="self" type="application/atom+xml" href="https://longshilin.com/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://longshilin.com/"/> <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator> <rights> © 2024 Elon </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>2023 OpenAI 开发者日主题演讲</title><link href="https://longshilin.com/posts/OpenAI-%E5%BC%80%E5%8F%91%E8%80%85%E6%97%A5%E4%B8%BB%E9%A2%98%E6%BC%94%E8%AE%B2/" rel="alternate" type="text/html" title="2023 OpenAI 开发者日主题演讲" /><published>2023-11-16T00:00:00+08:00</published> <updated>2023-11-16T10:49:44+08:00</updated> <id>https://longshilin.com/posts/OpenAI-%E5%BC%80%E5%8F%91%E8%80%85%E6%97%A5%E4%B8%BB%E9%A2%98%E6%BC%94%E8%AE%B2/</id> <content src="https://longshilin.com/posts/OpenAI-%E5%BC%80%E5%8F%91%E8%80%85%E6%97%A5%E4%B8%BB%E9%A2%98%E6%BC%94%E8%AE%B2/" /> <author> <name>Elon</name> </author> <category term="GPT" /> <summary> </summary> </entry> <entry><title>构建打包ET8的两种模式：Demo（状态同步）以及Lockstep（帧同步）</title><link href="https://longshilin.com/posts/%E6%9E%84%E5%BB%BA%E6%89%93%E5%8C%85ET8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F-Demo-%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5-%E4%BB%A5%E5%8F%8ALockstep-%E5%B8%A7%E5%90%8C%E6%AD%A5/" rel="alternate" type="text/html" title="构建打包ET8的两种模式：Demo（状态同步）以及Lockstep（帧同步）" /><published>2023-11-15T00:00:00+08:00</published> <updated>2023-11-15T00:00:00+08:00</updated> <id>https://longshilin.com/posts/%E6%9E%84%E5%BB%BA%E6%89%93%E5%8C%85ET8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F-Demo-%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5-%E4%BB%A5%E5%8F%8ALockstep-%E5%B8%A7%E5%90%8C%E6%AD%A5/</id> <content src="https://longshilin.com/posts/%E6%9E%84%E5%BB%BA%E6%89%93%E5%8C%85ET8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F-Demo-%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5-%E4%BB%A5%E5%8F%8ALockstep-%E5%B8%A7%E5%90%8C%E6%AD%A5/" /> <author> <name>Elon</name> </author> <category term="ET8" /> <summary> </summary> </entry> <entry><title>ET8教程系列</title><link href="https://longshilin.com/posts/ET8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/" rel="alternate" type="text/html" title="ET8教程系列" /><published>2023-11-15T00:00:00+08:00</published> <updated>2023-11-15T00:00:00+08:00</updated> <id>https://longshilin.com/posts/ET8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/</id> <content src="https://longshilin.com/posts/ET8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/" /> <author> <name>Elon</name> </author> <category term="ET8" /> <summary> 教程基于的分支版本：https://github.com/egametang/ET/tree/release8.0 构建打包ET8的两种模式：Demo（状态同步）以及Lockstep（帧同步） </summary> </entry> <entry><title>Go开发</title><link href="https://longshilin.com/posts/Learn-Go/" rel="alternate" type="text/html" title="Go开发" /><published>2023-03-02T14:00:00+08:00</published> <updated>2023-03-02T14:00:00+08:00</updated> <id>https://longshilin.com/posts/Learn-Go/</id> <content src="https://longshilin.com/posts/Learn-Go/" /> <author> <name>Elon</name> </author> <category term="GoLang" /> <summary> Go资源 Go学习文档: https://www.topgoer.com/ Go实战项目: https://github.com/flipped-aurora/gin-vue-admin Go学习路径：https://mp.weixin.qq.com/s/DIIpLUrGj2_-7Qd6vu0kuA Go编码规范：https://github.com/xxjwxc/uber_go_guide_cn#%E4%BB%8B%E7%BB%8D GORM配置外键，满足关联查询 一句话总结外键查询配置：gorm:"foreignKey:关联表的结构体字段;references:当前表的结构体字段; 不需要配置数据表的外键，只需在Model中定义外键和引用就可以了。 举例： type ProblemBasic... </summary> </entry> <entry><title>观察者模式</title><link href="https://longshilin.com/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" rel="alternate" type="text/html" title="观察者模式" /><published>2023-02-21T22:30:43+08:00</published> <updated>2024-05-28T14:32:09+08:00</updated> <id>https://longshilin.com/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id> <content src="https://longshilin.com/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" /> <author> <name>Elon</name> </author> <category term="游戏开发" /> <category term="游戏编程模式" /> <summary> 观察者模式是一种行为型模式，它定义了一种一对多的依赖关系，当一个对象的状态发生改变时，它的所有依赖对象都会收到通知并自动更新。在游戏开发中，观察者模式常用于实现事件系统（例如玩家获得道具或者触发战斗事件）、UI界面等。 下面是一个简单的观察者模式的示例： public interface GameEventObserver { void onGameEvent(GameEvent event); } public class Player implements GameEventObserver { public void onGameEvent(GameEvent event) { if (event.getType() == GameEventType.ENEMY_KILLED) { // Player gains e... </summary> </entry> </feed>
