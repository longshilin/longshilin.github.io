<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://longshilin.com/</id><title>Notes</title><subtitle>Blog Unity3d GameDevelopment Game Programme</subtitle> <updated>2023-03-23T23:17:11+08:00</updated> <author> <name>Elon</name> <uri>https://longshilin.com/</uri> </author><link rel="self" type="application/atom+xml" href="https://longshilin.com/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://longshilin.com/"/> <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator> <rights> © 2023 Elon </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Go开发</title><link href="https://longshilin.com/posts/Learn-Go/" rel="alternate" type="text/html" title="Go开发" /><published>2023-03-02T14:00:00+08:00</published> <updated>2023-03-23T23:16:45+08:00</updated> <id>https://longshilin.com/posts/Learn-Go/</id> <content src="https://longshilin.com/posts/Learn-Go/" /> <author> <name>Elon</name> </author> <category term="Go开发" /> <summary> Go资源 Go学习文档: https://www.topgoer.com/ Go实战项目: https://github.com/flipped-aurora/gin-vue-admin Go学习路径：https://mp.weixin.qq.com/s/DIIpLUrGj2_-7Qd6vu0kuA Go编码规范：https://github.com/xxjwxc/uber_go_guide_cn#%E4%BB%8B%E7%BB%8D GORM配置外键，满足关联查询 一句话总结外键查询配置：gorm:"foreignKey:关联表的结构体字段;references:当前表的结构体字段; 不需要配置数据表的外键，只需在Model中定义外键和引用就可以了。 举例： type ProblemBasic... </summary> </entry> <entry><title>观察者模式</title><link href="https://longshilin.com/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" rel="alternate" type="text/html" title="观察者模式" /><published>2023-02-21T22:30:43+08:00</published> <updated>2023-02-22T00:16:05+08:00</updated> <id>https://longshilin.com/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id> <content src="https://longshilin.com/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" /> <author> <name>Elon</name> </author> <category term="Unity" /> <category term="游戏编程模式" /> <summary> 观察者模式是一种行为型模式，它定义了一种一对多的依赖关系，当一个对象的状态发生改变时，它的所有依赖对象都会收到通知并自动更新。在游戏开发中，观察者模式常用于实现事件系统（例如玩家获得道具或者触发战斗事件）、UI界面等。 下面是一个简单的观察者模式的示例： public interface GameEventObserver { void onGameEvent(GameEvent event); } public class Player implements GameEventObserver { public void onGameEvent(GameEvent event) { if (event.getType() == GameEventType.ENEMY_KILLED) { // Player gains e... </summary> </entry> <entry><title>装饰器模式</title><link href="https://longshilin.com/posts/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/" rel="alternate" type="text/html" title="装饰器模式" /><published>2023-02-21T22:30:43+08:00</published> <updated>2023-02-22T00:16:05+08:00</updated> <id>https://longshilin.com/posts/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</id> <content src="https://longshilin.com/posts/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/" /> <author> <name>Elon</name> </author> <category term="Unity" /> <category term="游戏编程模式" /> <summary> 装饰器模式是一种结构型模式，它动态地给一个对象添加一些额外的职责，而不需要修改这个对象的类。装饰器模式可以将对象的功能进行组合，使得对象具有更加灵活的功能扩展能力。在游戏开发中，装饰器模式常用于实现技能系统、道具系统等。 例如，在一个冒险游戏中，玩家可以装备武器来增强攻击力，可以使用装饰器模式来实现武器系统： public abstract class Weapon { public abstract float GetDamage(); } public class Sword : Weapon { public override float GetDamage() { return 10; } } public abstract class WeaponDecorator : Weapon { protected Weapo... </summary> </entry> <entry><title>单例模式</title><link href="https://longshilin.com/posts/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" rel="alternate" type="text/html" title="单例模式" /><published>2023-02-21T22:30:43+08:00</published> <updated>2023-02-22T01:18:53+08:00</updated> <id>https://longshilin.com/posts/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id> <content src="https://longshilin.com/posts/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" /> <author> <name>Elon</name> </author> <category term="Unity" /> <category term="游戏编程模式" /> <summary> 策略模式是一种行为型模式，它定义了算法族，分别封装起来，让它们之间可以互相替换。策略模式可以让算法的变化独立于使用算法的客户端。在游戏开发中，策略模式常用于实现 AI 行为、战斗系统等。 例如，在一个回合制的战斗游戏中，玩家可以选择攻击、防御或逃跑。可以使用策略模式来实现不同的行为： public interface IBehaviorStrategy { void ExecuteBehavior(); } public class AttackStrategy : IBehaviorStrategy { public void ExecuteBehavior(){ // 攻击逻辑 } } public class DefendStrategy : IBehaviorStrategy { public void ExecuteB... </summary> </entry> <entry><title>命令模式</title><link href="https://longshilin.com/posts/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/" rel="alternate" type="text/html" title="命令模式" /><published>2023-02-21T22:30:43+08:00</published> <updated>2023-02-22T01:18:53+08:00</updated> <id>https://longshilin.com/posts/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</id> <content src="https://longshilin.com/posts/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/" /> <author> <name>Elon</name> </author> <category term="Unity" /> <category term="游戏编程模式" /> <summary> 状态模式是一种行为型模式，它允许对象在内部状态发生改变时改变它的行为。在游戏设计中，状态模式通常用于处理游戏对象的状态，例如游戏角色的生命值、装备状态等。下面是一个简单的状态模式的示例： public interface PlayerState { void attack(); void defend(); } public class NormalState implements PlayerState { public void attack() { // 普通状态下的攻击行为 } public void defend() { // 普通状态下的防御行为 } } public class InjuredState implements PlayerState { public ... </summary> </entry> </feed>
