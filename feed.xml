<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://longshilin.github.io/</id><title>Notes</title><subtitle>Blog Unity3d GameDevelopment Game Programme</subtitle> <updated>2023-02-21T23:53:37+08:00</updated> <author> <name>Elon</name> <uri>https://longshilin.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://longshilin.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://longshilin.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator> <rights> © 2023 Elon </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title></title><link href="https://longshilin.github.io/posts/2023-02-21-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" rel="alternate" type="text/html" title="" /><published>2023-02-21T23:53:37+08:00</published> <updated>2023-02-21T23:53:37+08:00</updated> <id>https://longshilin.github.io/posts/2023-02-21-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id> <content src="https://longshilin.github.io/posts/2023-02-21-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" /> <author> <name>Elon</name> </author> <summary> 观察者模式是一种行为型模式，它定义了一种一对多的依赖关系，当一个对象的状态发生改变时，它的所有依赖对象都会收到通知并自动更新。在游戏开发中，观察者模式常用于实现事件系统（例如玩家获得道具或者触发战斗事件）、UI界面等。 下面是一个简单的观察者模式的示例： public interface GameEventObserver { void onGameEvent(GameEvent event); } public class Player implements GameEventObserver { public void onGameEvent(GameEvent event) { if (event.getType() == GameEventType.ENEMY_KILLED) { // Player gains e... </summary> </entry> <entry><title></title><link href="https://longshilin.github.io/posts/2023-02-21-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/" rel="alternate" type="text/html" title="" /><published>2023-02-21T23:53:37+08:00</published> <updated>2023-02-21T23:53:37+08:00</updated> <id>https://longshilin.github.io/posts/2023-02-21-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</id> <content src="https://longshilin.github.io/posts/2023-02-21-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/" /> <author> <name>Elon</name> </author> <summary> 装饰器模式是一种结构型模式，它动态地给一个对象添加一些额外的职责，而不需要修改这个对象的类。装饰器模式可以将对象的功能进行组合，使得对象具有更加灵活的功能扩展能力。在游戏开发中，装饰器模式常用于实现技能系统、道具系统等。 例如，在一个冒险游戏中，玩家可以装备武器来增强攻击力，可以使用装饰器模式来实现武器系统： public abstract class Weapon { public abstract float GetDamage(); } public class Sword : Weapon { public override float GetDamage() { return 10; } } public abstract class WeaponDecorator : Weapon { protected Weapo... </summary> </entry> <entry><title></title><link href="https://longshilin.github.io/posts/2023-02-21-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" rel="alternate" type="text/html" title="" /><published>2023-02-21T23:53:37+08:00</published> <updated>2023-02-21T23:53:37+08:00</updated> <id>https://longshilin.github.io/posts/2023-02-21-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id> <content src="https://longshilin.github.io/posts/2023-02-21-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" /> <author> <name>Elon</name> </author> <summary> 下面这个是ChatGPT给出的解释和示例 策略模式是一种行为型模式，它定义了算法族，分别封装起来，让它们之间可以互相替换。策略模式可以让算法的变化独立于使用算法的客户端。在游戏开发中，策略模式常用于实现 AI 行为、战斗系统等。 例如，在一个回合制的战斗游戏中，玩家可以选择攻击、防御或逃跑。可以使用策略模式来实现不同的行为： public interface IBehaviorStrategy { void ExecuteBehavior(); } public class AttackStrategy : IBehaviorStrategy { public void ExecuteBehavior(){ // 攻击逻辑 } } public class DefendStrategy : IBehaviorStrateg... </summary> </entry> <entry><title></title><link href="https://longshilin.github.io/posts/2023-02-21-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/" rel="alternate" type="text/html" title="" /><published>2023-02-21T23:53:37+08:00</published> <updated>2023-02-21T23:53:37+08:00</updated> <id>https://longshilin.github.io/posts/2023-02-21-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</id> <content src="https://longshilin.github.io/posts/2023-02-21-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/" /> <author> <name>Elon</name> </author> <summary> 状态模式是一种行为型模式，它允许对象在内部状态发生改变时改变它的行为。在游戏设计中，状态模式通常用于处理游戏对象的状态，例如游戏角色的生命值、装备状态等。下面是一个简单的状态模式的示例： public interface PlayerState { void attack(); void defend(); } public class NormalState implements PlayerState { public void attack() { // 普通状态下的攻击行为 } public void defend() { // 普通状态下的防御行为 } } public class InjuredState implements PlayerState { public v... </summary> </entry> <entry><title></title><link href="https://longshilin.github.io/posts/2023-02-21-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" rel="alternate" type="text/html" title="" /><published>2023-02-21T23:53:37+08:00</published> <updated>2023-02-21T23:53:37+08:00</updated> <id>https://longshilin.github.io/posts/2023-02-21-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id> <content src="https://longshilin.github.io/posts/2023-02-21-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" /> <author> <name>Elon</name> </author> <summary> 工厂模式是一种常见的创建型模式，它用于创建一组相关的对象。在游戏设计中，工厂模式通常用于创建游戏对象，例如敌人、道具和装备等。下面是一个简单的工厂模式的示例： public interface GameObject { void update(); } public class Enemy implements GameObject { public void update() { // Update enemy logic } } public class GameObjectFactory { public static GameObject createGameObject(String type) { switch(type) { case "Enemy": ... </summary> </entry> </feed>
