<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://longshilin.com/</id><title>Notes</title><subtitle>Blog for Unity3d Game Development.</subtitle> <updated>2025-02-04T12:44:16+08:00</updated> <author> <name>admin</name> <uri>https://longshilin.com/</uri> </author><link rel="self" type="application/atom+xml" href="https://longshilin.com/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://longshilin.com/"/> <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator> <rights> © 2025 admin </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>05 - ETTask与同步上下文之间的关系</title><link href="https://longshilin.com/posts/05-ETTask%E4%B8%8E%E5%90%8C%E6%AD%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/" rel="alternate" type="text/html" title="05 - ETTask与同步上下文之间的关系" /><published>2025-02-04T00:00:00+08:00</published> <updated>2025-02-04T12:43:58+08:00</updated> <id>https://longshilin.com/posts/05-ETTask%E4%B8%8E%E5%90%8C%E6%AD%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</id> <content type="text/html" src="https://longshilin.com/posts/05-ETTask%E4%B8%8E%E5%90%8C%E6%AD%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/" /> <author> <name>admin</name> </author> <category term="ET7" /> <summary>在 ET 框架中，MainThreadSynchronizationContext 的作用是确保所有的异步任务都在主线程中执行，从而实现单线程协程模型。这个类的核心功能是通过 同步上下文（SynchronizationContext） 来控制异步任务的执行线程。 1. MainThreadSynchronizationContext 的作用 MainThreadSynchronizationContext 的主要职责是： 设置同步上下文：将当前的同步上下文设置为 ThreadSynchronizationContext，确保所有的异步任务都在主线程中执行。 任务调度：通过 Post 方法将任务调度到主线程执行。 更新任务队列：在每帧的 Update 方法中处理任务队列，执行所有待处理的任务。 2. 同步上下文的作用 同步上下文（Synchronizatio...</summary> </entry> <entry><title>05 - ETTask</title><link href="https://longshilin.com/posts/05-ETTask/" rel="alternate" type="text/html" title="05 - ETTask" /><published>2025-02-04T00:00:00+08:00</published> <updated>2025-02-04T01:39:01+08:00</updated> <id>https://longshilin.com/posts/05-ETTask/</id> <content type="text/html" src="https://longshilin.com/posts/05-ETTask/" /> <author> <name>admin</name> </author> <category term="ET7" /> <summary>ETTask相比于Task的优点： 生成代码极简，去除了多线程的支持，性能最好 对象池消除了Task GC 去掉了ETVoid 借助DeepSeek的辅助，从 设计目标、核心组件、工作原理 和 使用场景 四个方面，详细解读 ETTask 的实现。 1. 设计目标 ETTask 是 ET 框架中的异步任务实现，主要设计目标是： 轻量高效：适用于游戏开发中的高性能需求，避免线程阻塞和上下文切换。 协程支持：通过 async/await 实现协程逻辑，简化异步编程。 对象池优化：通过对象池减少内存分配，提升性能。 异常处理：提供统一的异常处理机制，避免异步任务中的异常丢失。 2. 核心组件 ETTask 的实现涉及多个核心组件，以下是它们的职责和关系： (1) ETTask 和 ETTask&amp;amp;lt;T&amp;amp;gt; 作用：表示一个异步任务，类似于 ...</summary> </entry> <entry><title>05 - ETTask WaitAny和WaitAll</title><link href="https://longshilin.com/posts/05-ETTask-WaitAny%E5%92%8CWaitAll/" rel="alternate" type="text/html" title="05 - ETTask WaitAny和WaitAll" /><published>2025-02-04T00:00:00+08:00</published> <updated>2025-02-04T02:24:14+08:00</updated> <id>https://longshilin.com/posts/05-ETTask-WaitAny%E5%92%8CWaitAll/</id> <content type="text/html" src="https://longshilin.com/posts/05-ETTask-WaitAny%E5%92%8CWaitAll/" /> <author> <name>admin</name> </author> <category term="ET7" /> <summary>ETTaskHelper 是 ET 框架中用于处理多个 ETTask 协同工作的工具类，提供了 WaitAny 和 WaitAll 方法，用于等待多个任务中的任意一个完成或全部完成。它的核心实现依赖于一个内部的 CoroutineBlocker 类。下面我们将详细解读 ETTaskHelper 的源码及其工作原理。 1. 核心功能 ETTaskHelper 提供了以下方法： WaitAny：等待多个任务中的任意一个完成。 WaitAll：等待多个任务全部完成。 IsCancel：检查 ETCancellationToken 是否已取消。 这些方法通过内部的 CoroutineBlocker 类实现任务的协同等待。 2. CoroutineBlocker 的实现 CoroutineBlocker 是 ETTaskHelper 的核心类，用于管理多个任务的完...</summary> </entry> <entry><title>04 - 多线程单线程与Task ETTask await async的关系</title><link href="https://longshilin.com/posts/04-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%8ETask-ETTask-await-async%E7%9A%84%E5%85%B3%E7%B3%BB/" rel="alternate" type="text/html" title="04 - 多线程单线程与Task ETTask await async的关系" /><published>2025-02-04T00:00:00+08:00</published> <updated>2025-02-04T12:07:51+08:00</updated> <id>https://longshilin.com/posts/04-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%8ETask-ETTask-await-async%E7%9A%84%E5%85%B3%E7%B3%BB/</id> <content type="text/html" src="https://longshilin.com/posts/04-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%8ETask-ETTask-await-async%E7%9A%84%E5%85%B3%E7%B3%BB/" /> <author> <name>admin</name> </author> <category term="ET7" /> <summary>在 ET 框架中，多线程、单线程 与 Task、ETTask、await、async 的关系是一个非常重要的话题。ET 框架的设计目标是高性能和低开销，因此在处理异步任务时，它采用了独特的单线程协程模型，同时结合了 Task、await 和 async 的语法糖来简化异步编程。下面我们将详细分析它们之间的关系和工作机制。 1. ET 框架的单线程协程模型 ET 框架的核心设计思想是 单线程协程，即所有的逻辑都在一个主线程中运行，通过协程的方式实现异步操作。这种设计有以下优点： 避免线程切换开销：单线程模型不需要频繁切换线程上下文，减少了性能开销。 简化并发编程：单线程模型避免了多线程编程中的锁竞争、死锁等问题。 高性能：通过事件驱动和协程调度，ET 框架能够高效地处理大量并发任务。 单线程与协程的关系 单线程：所有的逻辑都在一个线程中运行，没有多线程的并...</summary> </entry> <entry><title>03 - 单间管理器</title><link href="https://longshilin.com/posts/03-%E5%8D%95%E9%97%B4%E7%AE%A1%E7%90%86%E5%99%A8/" rel="alternate" type="text/html" title="03 - 单间管理器" /><published>2025-02-04T00:00:00+08:00</published> <updated>2025-02-04T00:41:20+08:00</updated> <id>https://longshilin.com/posts/03-%E5%8D%95%E9%97%B4%E7%AE%A1%E7%90%86%E5%99%A8/</id> <content type="text/html" src="https://longshilin.com/posts/03-%E5%8D%95%E9%97%B4%E7%AE%A1%E7%90%86%E5%99%A8/" /> <author> <name>admin</name> </author> <category term="ET7" /> <summary>为什么需要单间管理器： 统一管理单间类，单间类也需要管理生命周期，创建和清理的统一管理 统一管理基础库，灵活引入基础库。写一个Singleton包一下，比如YooAssets第三方插件。 消除静态字段，比如static dictionary这种变量，没有地方清理，unity关闭的时候没有一个地方统一清理，所以比如需要定义静态字段的时候都放到一个统一的singleton中作为单间的成员变量即可。 unity domain模式，可以不清理static字段，加速unity启动的速度 为什么不用组件：最底层做了一个单间管理器，在单间管理器的基础之上，再创建组件。 为什么要用Game.AddSingleton()创建单间： 不需要用TimeInfo.Instance直接这种方式来实例化单间类，因为很难看出第一次创建的地方，代码可读性高，明确知道单间初始化的地...</summary> </entry> </feed>
